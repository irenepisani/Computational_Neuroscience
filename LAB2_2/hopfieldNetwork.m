%% UNIVERSITY OF PISA
% Computer Science Department
% M.Sc. Computer Science, Artificial Intelligence

%% AUTHOR: IRENE PISANI
% email: i.pisani1@studenti.unipi.it
% matricola: 560104
% date: August 23

%% COMPUTATIONAL NEUROSCIENCE 22/23 - LABORATORY 2.2

% [ COMPLETED ] Assignment 1: Small Image Dataset
% [ No ] Bonus Track Assignment # 1 – Synthetic data
% [ No ] Bonus Track Assignment # 2 – How much can you remember?

%% Assignment 1: Small Image Dataset


% For solving these assignments run the main script:
    % hopfieldMain()
        % PARAMETERS: No input parameter are required. 
        % DESCRIPTION: Load original data and perform the storage phase of
        % the hopfield network with them. Then perform the retrieval phase
        % of the hopfield network with the distorted version of the
        % original vectors. Expploits hopfieldNetwork() and hopfieldPrturbation()
        % OUTPUT: the figure generated by hopfieldPlot()

% Other scripts or functions exploited in this assignments are:
    % hopfieldPerturbation()
    % hopfieldNetwork()
    % hopfieldPlot()

%% Hopfield Network class: properties and methods 
% Class for implementing the hopfield Network architecture and its train and storage phases.

classdef hopfieldNetwork
    
    properties
        weights
        bias
    end

    methods
        %% Initialize network and its weights
        % No parameter are required, it initiliaze the network defining
        % empty weigth and bias of the network.
        
        function obj = hopfieldNetwork()

            obj.weights = [];
            obj.bias = 0.5;
        end

        %% Storage phase for Hopfield Network 
        % Training of the network on a set of patterns
        % Storage() 
            % DESCRIPTION: function train the network on a set of pattern
            % given as parameter.
            % PARAMETER:
                % - patternMemory: A matrix where each columnrepresent a pattern to store.
            % OUTPUT:the network itself, with update weights;

        function obj = Storage(obj, patternMemory)
            
            % Get pattern dimensionality and number of pattern
            [dimPattern, nPattern] = size(patternMemory);

            % Initialize the weight matrix dimension
            obj.weights = zeros(dimPattern, dimPattern);

            % Learning phase: Compute the weight matrix

            % iterate over num. of pattern
            for i = 1 : nPattern
                pattern = patternMemory(:, i);
                obj.weights = obj.weights + pattern * pattern';
            end

            % weights update
            obj.weights = (obj.weights - nPattern * eye(size(obj.weights, 1))) / dimPattern;
            
        end
        
        %% Retrieval phase for Hopfield Network 
        % Retrieval()
            % PARAMETER:
                % - patternMemory: pattern used in storage phase 
                % - patternDistorted: distorted version of one of the
                % pattern used in storage phase
                % maxIteration: maximum number of iterations
            % DESCRIPION: perform reriveal phase for the given input
            % pattern
            % OUTPUT:
                % - energies: history of energy values after each state update
                % - overlaps: history of overlap values after each state update
                % - history: history of state after each state update

        function [energies, overlaps, history] = Retrieval(obj, patternMemory, patternDistorted, maxIterations)

            % initiliaze state
            x = patternDistorted; 
            
            [dimPattern, nPattern] = size(patternMemory);
            
            % initialize empty array for storing energy function values,
            % overlaps function values, and x after each state update. 
            energies = zeros(1, maxIterations * dimPattern);
            overlaps = zeros(nPattern, maxIterations * dimPattern);
            history = zeros(dimPattern, maxIterations * dimPattern);
            idx = 1;
            
            % ierate over epochs 
            for i = 1 : maxIterations
                
                % save previous state
                xPrev = x;
                
                % iterate over neuron picked up in random order
                for j = randperm(dimPattern)
                    
                    % compute the state
                    act = obj.weights(j,:) * x;
                    x(j) = sign(act + obj.bias);
                    if x(j) == 0
                        x(j) = 1;
                    end
                    
                    % update history of energy values
                    energies(idx) = -0.5 * (obj.weights * x)' * x - (obj.bias * ones(size(x)))' * x;
                    
                    % update history of overlaps values
                    overlaps(:, idx) = (x' * patternMemory) / dimPattern;
                   
                    % update history of states
                    history(:, idx) = x;

                    idx = idx + 1;

                end
                
                % stopping criteria
                if norm(x - xPrev) == 0
                    
                    % If early stopping take action -->
                    % stop retrieval phase and remove not-exploited space from the history 
                    overlaps = overlaps(:, 1:idx-1);
                    energies = energies(1:idx-1);
                    history = history(:, 1:idx-1);

                    break
                end
            end
        end
        
    end
end
